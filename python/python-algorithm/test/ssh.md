# 범위: List1, List2, String, Stack1-2, Queue

# 서술형 제외: 정렬, dfs, bfs

HTML: Hypertext Markup Language 웹페이지의 의미와 구조를 정의하는 언어
Hypertext: 웹페이지를 다른 페이지로 연결하는 링크. 참조를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트  // 비선형성, 상호연결성, 사용자 주도적 탐색

Markup Language: 태그 등을 이용하여 문서나 데이터의 구조를 명시하는 언어 (HTML, Markdown)

HTML구조
- !DOCTYPE html : 해당 문서가 html문서라는 것을 나타냄
- <html></html> : 전체 페이지의 콘텐츠를 포함
- <title></title> : 브라우저 탭, 즐겨찾기 시 표시되는 제목
- <head></head> : HTML문서 관련된 설명, 설정 등 컴퓨터가 식별하는 메타데이터 작성. 사용자에게 보이지 않음
- <body></body> : HTML 문서의 내용을 나타냄 / 페이지에 표시되는 모든 콘텐츠를 작성 / 1문서 1바디

하나의 HTML element(요소)는 여는 태그, 닫는 태그, 안의 내용으로 구성됨

HTML Text Structure: HTML의 주요 목적 중 하나는 텍스트 구조와 의미를 제공하는것
<h1> </h1> 현재 문서의 최상의 제목이라는 의미

CSS: cascading style sheet, 웹페이지의 디자인과 레이아웃을 구성하는 언어

선택자 selector / 선언 declaration / 속성 property - 값 value

적용방법: 인라인 스타일, 내부 스타일 시트, 외부 스타일 시트
인라인 스타일: html요소 안에 style 속성값으로 작성
내부 스타일시트: head 태그 안 style 태그에 작성
외부 스타일시트: 별소 css파일 생성후 html link 태그를 이용해 불러오기

CSS 선택자 selectors: html요소를 선택하여 스타일을 적용할 수 있도록 하는 선택자
기본 선택자: 전체선택자 * 요소선택자 tag 클래스선택자 class 아이디선택자 id 속성선택자 attr
결합자 combinator: 자손결합자 space 자식결합자 >

아이디선택자 - 문서에는 주어진 아이디를 가진 요소가 하나만 있어야함.

자손결합자 space : 첫번째 요소의 자손 요소들 선택.
하위레벨 상관없이 p span이라면 p 안의 모든 span을 선택

자식결합자 > : 첫번째 요소의 직계자식만 선택
한단계 아래 자식들만. ul > li 라면 ul 안에있는 모든 li를 선택.

명시도 specificity: 결과적으로 요소에 적용할 css 선언을 결정하기 위한 알고리즘
css selector의 가중치를 계산해 어떤 스타일을 적용할지 결정
동일한 요소를 가리키는 2개 이상의 css 규칙이 있는경우 가장 높은 명시도를 가진 selector의 스타일이 적용됨.


명시도가 높은 순: !important -> 인라인 스타일 -> 선택자 (id -> class -> 요소선택자) -> 소스코드 선언순서

CSS 상속: 기본적으로 CSS는 상속을 통해 부모요소의 속성을 자식에게 상속해 재사용성을 높임
상속되는 속성: text관련, opacity, visibility...
상속되지 않는 속성: box model 관련요소, position 관련요소

css box model: 웹페이지의 모든 HTML 요소를 감싸는 사각형 상자 모델
block box / inline box 
outer display type / inner display type 
outer display type - block: 항상 새로운 행으로 나뉨. width height 사용가능. padding margin border로 다른 요소를 상자로부터 밀어냄. width속성을 지정하지 않으면 박스는 inline 방향으로 사용가능한 공간을 모두 차지함 = 상위 컨테이너 너비 100%로 채운다.
outer display type - inline: 새로운 행으로 넘어가지 않음. width height 사용불가.
수직 방향으로 padding, margin, border 적용되지만 다른 요소 밀어낼 수 없음 / 수평 방향으로 padding, margin, border 적용되어 다른 요소 밀어낼 수 있음. / a, img, span, strong, em... 

inner display type: 박스 내부 요소들이 어떻게 배치될지 결정

css 스타일 가이드: 케밥케이스 kebab-case 사용, inline 되도록 사용하지 말것

css box model : 웹페이지의 모든 html 요소를 감싸는 사각형 상자 모델
내용, padding 안쪽여백, 테두리 border, 외부간격 margin으로 구성되어 요소의 크기와 배치를 결정

shorthand 속성

box-sizing: content-box / border-box

inline-block: 인라인과 블럭요소 사이의 중간지점. width height 가능. padding margin border로 인해 다른 요소가 상자에서 밀려남 . 줄바꿈 x. 요소가 줄바꿈 되는 것을 원하지 않으면서 너비와 높이를 적용하고 싶은 경우에 사용한다.

none: 요소를 화면에 표시하지 않고 공간도 부여 안한다

css position: 요소를 normal flow에서 제거하여 다른 위치로 배치하는 것.

static : 요소를 normal flow에 따라 배치
top right bottom left 속성 적용 안됨. 기본값

relative : 요소를 normal flow에 따라 배치. 자신의 원래 위치(static)을 기준으로 이동. top right bottom left속성으로 위치를 조정. 요소가 차지하는 공간은 static일 때와 같음: 다른 요소의 레이아웃에 영향을 주지 않는다.

absolute: 요소를 normal flow에서 제거. 가장 가까운 relative 부모요소를 기준으로 이동. 만족하는 부모 요소가 없다면 body 태그를 기준으로 함. 문서에서 요소가 차지하는 공간이 없어짐 !!!!!!!!

fixed: 요소를 normal flow에서 제거. 현재 화면영역 (viewport)를 기준으로 이동. 스크롤해도 항상 같은 위치에 유지. 문서에서 요소가 차지하는 공간이 없어짐 !!!

sticky: relative 와 fixed의 특성을 결합/ 스크롤 위치가 임계점에 도달하기 전에는 relative처럼 동작, 스크롤이 특정 임계점에 도달하면 fixed처럼 동작하여 화면에 고정. 만약 다음 sticky요소가 나오면 다음 스티키가 이전 스티키요소의  자리를 대체. 

z-index: 요소의 쌓임순서를 정의하는 속성. 값이 클수록 요소가 위에 쌓임. static이 아닐 때만 적용. 기본값 auto, 부모요소의 z-index값에 영향받음, 같은 부모 내에서만 z-index값 비교, 부모의 x-index가 낮으면 자식의 z-index가 아무리 높아도 부모보다 위로 올라갈 수 없음. z-index값이 같으면 html 문서 순서대로 쌓임.

flexbox: inner display type, 박스 내부의 요소들이 어떻게 배치될지를 결정, 요소를 행과 열 형태로 배치하는 1차원 레이아웃 방식
flex container, main axis, cross axis
main axis 주축: flex item들이 배치되는 기본축
main start - main end방향으로 배치.
cross axis 교차축: main axis에 수직인 축.
cross start - cross end

flex container: display flex 혹은 display inline-flex가 설정된 부모요소.
이 컨테이너의 1차 자식 요소들이 flex-item이 됨
flexbox속성값을 사용해 자식요소 flex-item들을 배치하는 주체.

flex container : display, flex-direction, flex-wrap, justify-content, align-items, align-content
flex item : align-self, flex-grow, flex-basis, order

flex-direction: reverse로 지정할경우 flex item 배치의 시작선과 끝선이 바뀐다

flex-wrap: flex item 목록이 flex container의 한행에 들어가지 않을경우 다른 행에 배치할지 여부 설정.

justify-content: 주축을 따라 flex item과 주위의 공간을 분배


align-content: 교차축을 따라 flex item과 주위에 공간을 분배
flex-wrap이 wrap, wrap-reverse로 설정된 여러 행에만 적용됨
한줄짜리 행엔 효과없음 (flex-wrap이 nowrap으로 설정된경우)

align-items : 교차축을 따라 flex item행을 정렬

align-self: 교차축을 따라 개별 flex item을 정렬

justify-items, justify-self 없는이유: margin auto를 통해 정렬및배치가 가능해서 필요 없음

flex-grow: 남는 행 여백을 비율에 따라 각 flex item에 분배, 아이템이 컨테이너 내에서 확장하는 비율을 지정, 반대는 flex-shrink

flex-basis: flex item의 초기 크기 값을 지정, width값과 동시적용된 경우 flex-basis가 우선

반응형 레이아웃: 다양한 디바이스와 화면 크기에 자동으로 적응하여 콘텐츠를 최적으로 표시하는 웹 레이아웃 방식

마진 상쇄 margin collapsing: 두 블럭타입 요소의 margin top과 margin bottom 이 만나 더 큰 마진으로 결합되는 현상
이유: 복잡한 레이아웃에서 요소 간 간격을 일관되게 유지하기 위함. 요소간의 간격을 더 예측 가능하고 관리하기 쉽게 만든다. 일관성, 단순화를 위함.

flexbox shorthand속성: flex-flow ( flex-flow: flex-direction flex-wrap )

bootstrap: CSS 프론트엔드 프레임워크(toolkit), 미리 만들어진 다양한 디자인 요소들을 제공하여 웹사이트를 빠르고 쉽게 개발할 수 있도록 함.\

CDN : content delivery network, 지리적 제약 없이 빠르고 안전하게 콘텐츠를 전송할 수 있는 전송 기술 / 서버와 사용자 사이 물리적인 거리를 줄여 콘텐츠 로딩에 소요되는 시간 최소화 (웹페이지 로드 속도 높임) / 지리적으로 사용자와 가까운 cdn 서버에 콘텐츠를 저장해서 사용자에게 전달

mt-5 : property sides - size
tbse top bottom start end y :topbottom, x : leftright, blank  = 4 sides

0 1 2 3 4 5 auto
0 4 8 16 24 48px auto
0 0.25 0.5 1 1.5 3 rem

reset css: 모든 html 요소 스타일을 일관된 기준으로 재설정하는 간결하고 압축된 규칙 세트
html element, table, list등의 요소들에 일관성 있게 스타일을 적용시키는 기본 단계

reset css 사용 배경: 모든 브라우저는 각자의 user agent stylesheet를 가지고 있음. (웹사이트를 보다 읽기 편하게 하기위해) 그러나 이 설정은 브라우저마다 상이함. 모든 브라우저에서 웹사이트를 동일하게 보이게 만들기 어려우므로, 모두 똑같은 스타일 상태로 초기화한 상태에서 스타일 개발을 시작하기 위해서 reset css를 함.

normalize css: reset css의 대표적인 방법. 웹표준 기준으로 브라우저중 하나가 불일치한다면 차이가 있는 브라우저를 수정.

bootstrap사용법
display headings
inline text elements

bootstrap component 부트스트랩에서 제공하는 ui 관련 요소: 버튼, 네비게이션 바, 카드 폼, 드롭다운 등 / alerts, badges, buttons, cards, navbar
컴포넌트 이점: 일관된 디자인을 제공하여 웹사이트의 구성 요소를 구축하는 데 유용하게 활용


semantic web: 웹 데이터를 의미론적으로 구조화된 형태로 표현하는 방식
html semantic element: 기본적인 모양과 기능 이외에 의미를 가지는 html 요소 , 검색엔진 및 개발자가 웹페이지 콘텐츠를 이해하기 쉽도록. header nav main article section aside footer..

CSS방법론: css를 효율적이고 유지보수가 용이하게 작성하기 위한 일련의 가이드라인
OOCSS : Object Oriented CSS : 객체 지향적 접근법을 적용하여 css를 구성하는 방법론
OOCSS 기본 원칙: 구조와 스킨을 분리 / 컨테이너와 콘텐츠를 분리

구조와 스킨을 분리함으로써 재사용 가능성을 높임.
모든 버튼의 공통구조를 정의 + 각각의 스킨(배경색, 폰트색상 등..)을 정의

컨테이너와 콘텐츠분리 : 객체에 직접 적용하는 대신 객체를 둘러싸는 컨테이너에 스타일을 적용.
스타일을 정의할 때 위치에 의존적인 스타일을 사용하지 않도록 함.
콘텐츠를 다른 컨테이너로 이동하거나 재배치할 때 스타일이 깨지는 것을 방지

bootstrap을 사용하는 이유: 
가장 많이 사용되는 프레임워크
사전에 디자인된 다양한 컴포넌트 및 기능, 빠른 개발과 유지보수
손쉬운 반응형웹 디자인 구현
커스터마이징 용이
크로스브라우징 지원(모든 주요 브라우저에서 작동하도록 설계됨)

의미론적 마크업이 필요한이유: 검색엔진 최적화 (SEO): 검색엔진이 해당 웹사이트를 분석하기 쉽게 만들어 검색 순위에 영향을 줌. / 웹접근성 web accessibility: 웹사이트, 도구, 기술이 고령자나 장애를 가진 사용자들이 사용할 수 있도록 설계 및 개발

grid system: 웹페이지의 레이아웃을 조정하는 데 사용되는 12개의 컬럼으로 구성된 시스템
목적: 반응형 디자인을 지원해 웹페이지를 다양한 기기에서 적절하게 표시할 수 있도록 도움

반응형 웹 디자인: 디바이스 종류나 화면 크기에 상관없이 어디서든 일관된 레이아웃 및 사용자 경험을 제공하는 디자인 기술

container: 컬럼들을 담고있는 공간
컬럼: 실제 컨텐츠를 포함하는 부분
거터: 컬럼과 컬럼사이 여백
1개의 row안에 12개의 컬럼영역 구성, 각요소는 12개중 몇개를 차지할것인지 지정됨

중첩 nesting

gutter: x축은 패딩, y축은 마진으로 여백생성. 실제 컬럼간 좌우간격은 변하지않으며 패딩으로 인해 컬럼안에 contents의 너비가변한다.

6개의 breakpoints: 웹페이지를 다양한 화면크기에서 적절하게 배치하기위한 분기점
xs, sm, md, lg, xl, xxl
<576 >=576 768 992 1200 1400
각 breakpoints마다 설정된 최대 너비값 이상으로 화면이 커지면 grid system 동작이 변경됨

UX user experience 제품이나 서비스를 사용하는 사람들이 느끼는 전체적인 경험과 만족도를 개선하고 최적화하기 위한 디자인과 개발 분야
UI user interface 서비스와 사용자 간의 상호작용을 가능하게 하는 디자인 요소들을 개발하고 구현하는 분야

grid cards: row-cols 클래스를 이용해 행당 표시할 열(카드)수를 손쉽게 제어할 수 있음

################################################################

부분집합: 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다. 집합의 원소가 n개일때: 공집합을 포함한 부분집합의 수는 2^n개임 ( 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의수와 같음)

################################################################
################################################################
################################################################
################################################################
################################################################

스택의 특성: 자료를 쌓아올린 형태의 자료구조.
스택에 저장된 자료는 선형 구조를 갖는다. (자료 간의 관계가 1대1의 관계를 갖는다)
마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출 (Last In First Out)
마지막 삽입된 원소의 위치를 top이라 부른다.

스택 구현시 고려사항:
일차원 배열을 사용하여 구현할 경우, 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.
이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법이며, 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가진다.

재귀호출: 필요한 함수가 자신과 같은 경우 자신을 다시 호출하는 구조
함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성할 수 있다.

재귀호출의 문제점: 엄청난 중복 호출이 존재한다. -> memoization

memoization 메모이제이션은 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적 실행속도를 빠르게 하는 기술이다. 메모이제이션은 동적 계획법의 핵심이 되는 기술이다.

dp 동적 계획 dynamic programming 알고리즘: 그리디처럼 최적화 문제를 해결하는 알고리즘
동적 계획 알고리즘: 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후, 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 dp를 구현한 것이 성능 면에서 보다 효율적인데, 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.

문자열 수식 계산의 일반적인 방법: 중위 표기법의 수식을 후위 표기법으로 스택을 이용해 변경한다. -> 후위 표기법의 수식을 스택을 이용하여 계산한다.
중위 표기법 infix notation: 연산자를 피연산자의 가운데 표기하는 방법
후위 표기법 postfix notation: 연산자를 피연산자 뒤에 표기하는 방법


백트래킹: 해를 찾는 도중에 막히면, 즉 해가 아니면 되돌아가서 다시 해를 찾아가는 기법
최적화 문제와 결정 문제를 해결할 수 있음
결정 문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes 또는 no가 답하는 문제

백트래킹과 깊이우선탐색dfs과의 차이: dfs는 모든 경로를 추적하는 데 비해 백트래킹은 불필요한 경로를 조기에 차단한다. / 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄인다.(가지치기) / 깊이우선탐색을 가하기에는 경우의 수가 너무 많음. 즉 N!가지의 경우의 수를 가진 문제에 대해 깊이우선탐색을 가하면 처리 불가능. / 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간(exponential time)을 요하므로 처리 불가능하다. / 모든 후보를 검사하는 것이 아님.

백트래킹 기법: 어떤 노드의 유망성을 점검한 후 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 간다. 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다. / 가치치기 pruning: 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.

백트래킹을 이용한 알고리즘 절차:
상태 공간 트리의 깊이 우선 검색을 실시한다. -> 각 노드가 유망한지를 점검한다. -> 만일 그 노드가 유망하지 않으면 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

부분집합: 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라 하며, 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n개이다.


큐의 특성:
스택처럼 삽입과 삭제의 위치가 제한적인 자료구조.
FIFO first in first out 구조를 가지며, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.
뒤에서는 삽입만, 앞에서는 삭제만 이루어지는 구조
삽입: 인큐, 삭제: 디큐, front / rear

원형큐를 사용하는 이유
선형큐를 이용해 원소의 삽입과 삭제를 계속할 경우 배열의 앞부분에 활용할 공간이 있음에도 불구하고 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨. 이를 해결하기 위해 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 이동시킬 수 있으나 원소 이동에 많은 시간이 소요되어 큐의 효율성이 떨어짐
따라서 일차원 배열을 이용하되 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정할 수 있다

연결큐: 단순 연결 리스트를 이용한 큐
큐의 원소: 단순 연결 리스트의 노드
큐의 원소 순서: 노드의 연결 순서, 링크로 연결되어 있음.

deque: 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너.

버퍼: 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역.
버퍼링: 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작
버퍼의 자료구조: FIFO인 큐 (입력 출력 전달)